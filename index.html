<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#34495e">
  <title>LengPeng</title>
  <link rel="alternate" href="path/of/rss" type="application/atom+xml">
  <link rel="shortcut icon" type="image/ico" href="/favicon.ico">
  
<link rel="stylesheet" href="/css/style.css">

  

  

  

  

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div class="mobile-header">
    <span><i class="iconfont icon-turnon" id="mobile-nav-toggle"></i></span>
    <div class="mobile-logo">
      <a href="/.">LengPeng</a>
    </div>
  </div>
  <div class="page" id="mobile-nav-panel">
    <div class="container">
      <header class="site-nav">
      <div class="nav-content">
        <div class="logo">
          <a href="/">LengPeng</a>
        </div>
        <nav class="navbar">
          <ul>
            
              <li class="menu-item">
                <a href="/" class="menu-item-link"><i class="iconfont icon-home"></i>首页</a>
              </li>
            
              <li class="menu-item">
                <a href="/archives" class="menu-item-link"><i class="iconfont icon-archive"></i>归档</a>
              </li>
            
              <li class="menu-item">
                <a href="/categories" class="menu-item-link"><i class="iconfont icon-category"></i>分类</a>
              </li>
            
              <li class="menu-item">
                <a href="/about" class="menu-item-link"><i class="iconfont icon-about"></i>关于</a>
              </li>
            
          </ul>
        </nav>
      </div>
</header>

      <div class="banner">
  <div class="show">
    <!-- <img src="/" alt="banner"> -->
    <div class="banner-title">
      
        <div class="intro">
          practice makes perfect
        </div>
      
    </div>
  </div>
</div>

      <main class="main"id="main">
          <section class="posts">
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2021/01/06/working/">工作中</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2021-01-06</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a>
              
          
          <!---------------------------------------->
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="Java-maven-打包后-不能读取resource目下的证书及其他文件："><a href="#Java-maven-打包后-不能读取resource目下的证书及其他文件：" class="headerlink" title="Java maven 打包后 不能读取resource目下的证书及其他文件："></a>Java maven 打包后 不能读取resource目下的证书及其他文件：</h1><p>原读取方式：FileReader.create(File, charset).readString();      </p>
<p>原因在于这种获取配置文件的方式无法获取压缩包中的配置文件   </p>
<p>解决方案以文件流方式读取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Resource resource &#x3D; new ClassPathResource(wxPayV3Config.getKeyPath());</span><br><span class="line">  InputStream is &#x3D; resource.getStream();</span><br><span class="line">  String originalKey &#x3D; &quot;&quot;;</span><br><span class="line">  byte[] buf &#x3D; new byte[1024];</span><br><span class="line">  int len &#x3D; 0;</span><br><span class="line">  while ((len &#x3D; is.read(buf)) !&#x3D; -1) &#123;</span><br><span class="line">    originalKey +&#x3D; new String(buf, 0, len);</span><br><span class="line">  &#125;</span><br><span class="line">  is.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="Spring-boot-整合consul-和feign不成功调用报错"><a href="#Spring-boot-整合consul-和feign不成功调用报错" class="headerlink" title="Spring boot 整合consul 和feign不成功调用报错"></a>Spring boot 整合consul 和feign不成功调用报错</h1><p>spring boot  整合consul 和feign不成功，项目启动正常，也正常注册到consul，可是在请求时，报错找不到类<br>java.lang.ClassNotFoundException: com.netflix.config.CachedDynamicIntProperty</p>
<p>看样子是类冲突了  </p>
<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; </span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt; </span><br><span class="line">&lt;exclusions&gt; </span><br><span class="line">	&lt;exclusion&gt; </span><br><span class="line">		&lt;groupId&gt;com.netflix.archaius&lt;&#x2F;groupId&gt; </span><br><span class="line">		&lt;artifactId&gt;archaius-core&lt;&#x2F;artifactId&gt; </span><br><span class="line">	&lt;&#x2F;exclusion&gt;</span><br><span class="line"> &lt;&#x2F;exclusions&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





        
        <!-------------->
      </div>
      <div class="post-tags">
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2020/12/08/interview/">XXXX</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2020-12-08</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a>
              
          
          <!---------------------------------------->
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>强<br>软<br>弱——<br>虚：与队列结合使用——实际无使用场景；管理直接内存；</p>
<h2 id="Arraylist-与-LinkedList、Vector-区别"><a href="#Arraylist-与-LinkedList、Vector-区别" class="headerlink" title="Arraylist 与 LinkedList、Vector 区别"></a>Arraylist 与 LinkedList、Vector 区别</h2><pre><code>Arraylist 与 LinkedList 两个都是不保证线程安全；Vector是线程安全的；
Arraylist 底层数据结构是数组；LinkedList是双向链表；</code></pre>
<h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><p>HashMap主要由数组和链表组成，他不是线程安全的。核心的点就是put插入数据的过程，get查询数据以及扩容的方式。JDK1.7和1.8的主要区别在于头插和尾插方式的修改，头插容易导致HashMap链表死循环，并且1.8之后加入红黑树对性能有提升。</p>
<ul>
<li>put插入数据流程<br>往map插入元素的时候首先通过对key hash然后与数组长度-1进行与运算((n-1)&amp;hash)，都是2的次幂所以等同于取模，但是位运算的效率更高。找到数组中的位置之后，如果数组中没有元素直接存入，反之则判断key是否相同，key相同就覆盖，否则就会插入到链表的尾部，如果链表的长度超过8，则会转换成红黑树，最后判断数组长度是否超过默认的长度*负载因子也就是12，超过则进行扩容。</li>
<li>get查询数据<br>查询数据相对来说就比较简单了，首先计算出hash值，然后去数组查询，是红黑树就去红黑树查，链表就遍历链表查询就可以了。</li>
<li>resize扩容过程<br>扩容的过程就是对key重新计算hash，然后把数据拷贝到新的数组。</li>
</ul>
<p>hash冲突.链地址法<br>　　 这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>采⽤CAS和synchronized来保证并发安全;<br>数据结构跟HashMap1.8的结构类似，数组+链表/红⿊⼆叉树;synchronized只锁定当前链表或红⿊⼆叉树的⾸节点，这样只要hash不冲突，就不会产⽣并发，效率⼜提升N倍。</p>
<h2 id="并发与并⾏"><a href="#并发与并⾏" class="headerlink" title="并发与并⾏"></a>并发与并⾏</h2><p>并发：同一时间段，有多个任务在执行；<br>并行：单位时间内，多个任务同时执行；</p>
<p>并发编程的⽬的就是为了能提⾼程序的执⾏效率，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>互斥；请求并保持；不可剥夺；循环等待；</p>
<h2 id="为什么我们调⽤-start-⽅法时会执⾏-run-⽅法"><a href="#为什么我们调⽤-start-⽅法时会执⾏-run-⽅法" class="headerlink" title="为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法"></a>为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法</h2><p>调用start方法可启动线程并是使线程进入就绪状态；为调用run只是一个普通方法调用；</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程：资源分配的基本单位；<br>线程：程序执行的基本单位；</p>
<p>进程是程序的一次执行，是系统进行资源分配和调度的独立单位，他的作用是是程序能够并发执行提高资源利用率和吞吐率。<br>由于进程是资源分配和调度的基本单位，因为进程的创建、销毁、切换产生大量的时间和空间的开销，进程的数量不能太多，而线程是比进程更小的能独立运行的基本单位，他是进程的一个实体，可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。线程基本不拥有系统资源，只有一些运行时必不可少的资源，比如程序计数器、寄存器和栈，进程则占有堆、栈。</p>
<h2 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h2><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。</p>
<p>synchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为监视器锁，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。<br>执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进入等待队列中。<br>执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。<br>synchronized是排它锁，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁，而且由于Java中的线程和操作系统原生线程是一一对应的，线程被阻塞或者唤醒时时会从用户态切换到内核态，这种转换非常消耗性能。</p>
<p>从内存语义来说，加锁的过程会清除工作内存中的共享变量，再从主内存读取，而释放锁的过程则是将工作内存中的共享变量写回主内存。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>相比于synchronized，ReentrantLock需要显式的获取锁和释放锁，<br>和synchronized有什么区别<br>等待可中断，当持有锁的线程长时间不释放锁的时候，等待中的线程可以选择放弃等待，转而处理其他的任务。<br>公平锁：synchronized和ReentrantLock默认都是非公平锁，但是ReentrantLock可以通过构造函数传参改变。只不过使用公平锁的话会导致性能急剧下降。<br>绑定多个条件：ReentrantLock可以同时绑定多个Condition条件对象。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile关键字的主要作⽤就是保证变量的可⻅性然后还有⼀个作⽤是防⽌指令重排序</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 ThreadLocal 变量名的由来。他们可以使⽤ get（） 和 set（） ⽅法来获取默认值或将其值更改为当前线程所存的副本的值，从⽽避免了线程安全问题。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>池化技术的思想主要是为了减少每次获取资源的消耗，提⾼对资源的利⽤率。<br>降低资源消耗。提⾼响应速度。提⾼线程的可管理性。</p>
<p>Runnable 接⼝不会返回结果或抛出检查异常，但是 Callable 接⼝可以；<br>execute() ⽅法⽤于提交不需要返回值的任务，所以⽆法判断任务是否被线程池执⾏成功与否；</p>
<p>submit() ⽅法⽤于提交需要返回值的任务。线程池会返回⼀个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执⾏成功，并且可以通过 Future 的 get() ⽅法来获取返回值， get() ⽅法会阻塞当前线程直到任务完成，⽽使⽤ get（long timeout，TimeUnit unit） ⽅法则会阻塞当前线程⼀段时间后⽴即返回，这时候有可能任务没有执⾏<br>完。</p>
<p>1 先判断线程池中的核心线程们是否空闲，如果空闲，就把这个新的任务指派给某一个空闲线程去执行。<br>2 如果没有空闲，并且当前线程池中的核心线程数还小于 corePoolSize，那就再创建一个核心线程。<br>3 如果线程池的线程数已经达到核心线程数，并且这些线程都繁忙，就把这个新来的任务放到等待队列中去。<br>4 如果等待队列又满了，那么查看一下当前线程数是否到达maximumPoolSize，如果还未到达，就继续创建线程。如果已经到达了，就交给</p>
<p>RejectedExecutionHandler来决定怎么处理这个任务。<br>AbortPolicy 来拒绝新任务的处理。直接抛出异常，这是默认策略；<br>CallerRunsPolicy：用调用者所在的线程来执行任务；<br>DiscardPolicy ： 不处理新任务，直接丢弃掉。<br>DiscardOldestPolicy ： 此策略将丢弃最早的未处理的任务请求。</p>
<h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h2><p>AQS（Abstract Queued Synchronizer）是一个抽象的队列同步器，通过维护一个共享资源状态（Volatile Int State）和一个先进先出（FIFO）的线程等待队列来实现一个多线程访问共享资源的同步框架。</p>
<p>AQS为每个共享资源都设置一个共享资源锁，线程在需要访问共享资源时首先需要获取共享资源锁，如果获取到了共享资源锁，便可以在当前线程中使用该共享资源，如果获取不到，则将该线程放入线程等待队列，等待下一次资源调度</p>
<p>AQS定义了两种资源共享方式：独占式（Exclusive）和共享式（Share）。<br>◎ 独占式：只有一个线程能执行，具体的Java实现有ReentrantLock。<br>◎ 共享式：多个线程可同时执行，具体的Java实现有Semaphore和CountDownLatch。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p>
<p>CAS叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：<br>变量内存地址，V表示<br>旧的预期值，A表示<br>准备设置的新值，B表示<br>当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作</p>
<p>缺点：ABA问题；循环时间长开销大;只能保证一个共享变量的原子操作</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h2><p>类加载检查；分配内存；初始化零值；设置对象头；执行init方法；<br>堆内存非配策略：对象优先在新生区；大对象进老年代；长期存活的锦老年代；</p>
<h4 id="判断无用的常量"><a href="#判断无用的常量" class="headerlink" title="判断无用的常量"></a>判断无用的常量</h4><p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引⽤该字符串常量的话，就说明常量<br>“abc” 就是废弃常量，如果这时发⽣内存回收的话⽽且有必要的话，”abc” 就会被系统清理出常量池。</p>
<h5 id="判断无用的类"><a href="#判断无用的类" class="headerlink" title="判断无用的类"></a>判断无用的类</h5><p>该类的所有实例被回收；<br>该类的classloader被回收；<br>该类对应的 Class对象没有任何地方被引用，无法在任何地方通过反射访问；</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><h2 id="锁的优化机制"><a href="#锁的优化机制" class="headerlink" title="锁的优化机制"></a>锁的优化机制</h2><p>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁   </p>
<p>自旋锁：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环，可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10次，可以使用-XX:PreBlockSpin设置。   </p>
<p>自适应锁 </p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="spring-用到的模式："><a href="#spring-用到的模式：" class="headerlink" title="spring 用到的模式："></a>spring 用到的模式：</h2><ul>
<li>单例模式：Spring 中的 Bean 默认情况下都是单例的</li>
<li>工厂模式：工厂模式主要是通过 BeanFactory 和 ApplicationContext 来生产 Bean 对象。</li>
<li>代理模式：最常见的 AOP 的实现方式就是通过代理来实现，Spring主要是使用 JDK 动态代理和 CGLIB 代理。</li>
<li>模板方法模式：主要是一些对数据库操作的类用到，比如 JdbcTemplate、JpaTemplate，因为查询数据库的建立连接、执行查询、关闭连接几个过程，非常适用于模板方法。</li>
</ul>
<h2 id="IOC-AOP"><a href="#IOC-AOP" class="headerlink" title="IOC AOP"></a>IOC AOP</h2><p>ioc 是⼀种设计思想：就是将原本在程序中⼿动创建对象的控制<br>权，交由Spring框架来管理；将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊;提供了BeanFactory和applicationContext来管理</p>
<p>AOP面向切面编程；他是一个编程范式，目的是提高代码的模块性；基于动态代理的方式实现；如果实现了接口的话就会使用JDK动态代理，否则使用CGLIB代理；Spring中 AOP 的应用主要体现在 事务、日志、异常处理等方面，通过在代码的前后做一些增强处理，可以实现对业务逻辑的隔离，提高代码的模块化能力，同时也是解耦。Spring主要提供了 Aspect 切面、JoinPoint 连接点、PointCut 切入点、Advice 增强等实现方式。</p>
<p>Spring AOP 基于动态代理实现，属于运行时增强。<br>AspectJ 则属于编译时增强，主要有3种方式：<br>就是 Spring AOP 只能在运行时织入，不需要单独编译，性能相比 AspectJ 编译织入的方式慢，而 AspectJ 只支持编译前后和类加载时织入，性能更好，功能更加强大</p>
<p>BeanFactory 是 Bean 的工厂， ApplicationContext 的父类，IOC 容器的核心，负责生产和管理 Bean 对象。</p>
<p>FactoryBean 是 Bean，可以通过实现 FactoryBean 接口定制实例化 Bean 的逻辑，通过代理一个Bean对象，对方法前后做一些操作。</p>
<h2 id="Spring-中的-bean-的作⽤域有"><a href="#Spring-中的-bean-的作⽤域有" class="headerlink" title="Spring 中的 bean 的作⽤域有"></a>Spring 中的 bean 的作⽤域有</h2><ul>
<li>singleton : 唯⼀ bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建⼀个新的 bean 实例</li>
<li>request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效</li>
<li>session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作⽤域，仅仅在基于portlet的web应⽤中才有意义，Spring5已<br>经没有了。</li>
</ul>
<p>单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。</p>
<pre><code>在Bean对象中尽量避免定义可变的成员变量
在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式）。</code></pre>
<h2 id="Component-和-Bean-的区别是什么"><a href="#Component-和-Bean-的区别是什么" class="headerlink" title="@Component 和 @Bean 的区别是什么"></a>@Component 和 @Bean 的区别是什么</h2><p> 作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法</p>
<h2 id="将⼀个类声明为Spring的-bean-的注解有哪些"><a href="#将⼀个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将⼀个类声明为Spring的 bean 的注解有哪些"></a>将⼀个类声明为Spring的 bean 的注解有哪些</h2><p>@Component;@Repository;@Service;@Controller</p>
<h2 id="SpringBean生命周期"><a href="#SpringBean生命周期" class="headerlink" title="SpringBean生命周期"></a>SpringBean生命周期</h2><ul>
<li><p>实例化，创建一个Bean对象</p>
</li>
<li><p>填充属性，为属性赋值——按照spring上下文对实例化的bean进行配置——ioc注入</p>
</li>
<li><p>初始化<br>  如果实现了 xxxAware 接口，通过不同的aware接口拿到apring容器的资源<br>  如果实现了beanPostProcessor接口，则会调用该接口的postProcessBeforInitiazation 和postProcessAfterInitiazation方法<br>  如果配置了init-mathod方法，则会执行改方法 </p>
</li>
<li><p>销毁<br>  容器关闭后，如果bean实现了DisposeableBean接口，则会调用该接口的destroy方法<br>  如果配置了destroy-method方法，则会执行该方法</p>
</li>
</ul>
<h2 id="Spring是怎么解决循环依赖的"><a href="#Spring是怎么解决循环依赖的" class="headerlink" title="Spring是怎么解决循环依赖的"></a>Spring是怎么解决循环依赖的</h2><p>三级缓存：<br>第一级缓存：用来保存实例化、初始化都完成的对象<br>第二级缓存：用来保存实例化完成，但是未初始化完成的对象<br>第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象</p>
<h2 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h2><p>isolation_default:——mysql repeatable-read<br>readUncommit<br>readcommit<br>repeat-read<br>serializable 串行</p>
<p>read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。<br>read commit 读已提交，两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。<br>repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。<br>serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。</p>
<h2 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a>Spring事务传播机制</h2><p>Propagation_required:如果当前没有事务，就创建一个新的，存在就加入该事务；——默认选择<br>requires_new ：不管存不存在都创建新事务<br>nested:如果当前存在事务，则嵌入事务内部执行，如果没有就创建新的事务<br>not_supported：以非事务方式执行操作，存在就把当前事务挂起<br>never：以非事务方式执行操作，存在就跑出异常<br>mandatory:支持当前事务，如果当前事务存在，就加入该事务，如果不存在则抛出异常；<br>supports：如果当前事务存在，就加入该事务，不存在就以非事务执行</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><pre><code>将类的各个部分封装成其他属性；Field Constructor Method   

获取public   
    getFields():Field []    
    getField(String a):Field   

获取所有：要忽略访问修饰符的安全规则——setAccessible(true);暴力反射   
    getDeclaredFields():Field []    
    getDeclaredField(String a):Field   

Field 获取属性、设置值   
Constructor 创建对象   
Method 执行方法 invoke()   </code></pre>
<h2 id="说说Spring-Boot-启动流程"><a href="#说说Spring-Boot-启动流程" class="headerlink" title="说说Spring Boot 启动流程"></a>说说Spring Boot 启动流程</h2><ul>
<li>准备环境，根据不同的环境创建不同的Environment</li>
<li>准备、加载上下文，为不同的环境选择不同的Spring Context，然后加载资源，配置Bean   </li>
<li>初始化，这个阶段刷新Spring Context，启动应用</li>
<li>最后结束流程</li>
</ul>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p>myisam:支持全文检索、压缩、空间函数……；不支持事务及行级锁；一般用于读多写少的场景；不支持外键，索引与数据分开存储。<br>innodb:基于聚簇索引建立的，支持事物，外键；<br>    并通过MVCC来支持高并发、索引和数据存储在一起；</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>按照数据结构：B+树和hash索引；<br>B+ 树时左小右大的顺序存储结构，节点只包含id索引列，而叶子结点包含索引列和数据——聚簇索引；一张表只能有一个主键作为聚簇索引；假设没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有的话则会隐式定义一个主键作为聚簇索引。</p>
<p>索引覆盖和回表：覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。</p>
<h2 id="mysql锁分为共享锁和排他锁，也叫做读锁和写锁"><a href="#mysql锁分为共享锁和排他锁，也叫做读锁和写锁" class="headerlink" title="mysql锁分为共享锁和排他锁，也叫做读锁和写锁"></a>mysql锁分为共享锁和排他锁，也叫做读锁和写锁</h2><p>读锁是共享的，可以通过lock in share mode实现，这时候只能读不能写。<br>写锁是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和行锁两种。<br>表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。</p>
<p>行锁又可以分为乐观锁和悲观锁，悲观锁可以通过for update实现，乐观锁则通过版本号实现。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li>原子性指的是一个事务中的操作要么全部成功，要么全部失败。</li>
<li>一致性指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设中间sql执行过程中系统崩溃A也不会损失100块，因为事务没有提交，修改也就不会保存到数据库。</li>
<li>隔离性指的是一个事务的修改在最终提交前，对其他事务是不可见的。</li>
<li>持久性指的是一旦事务提交，所做的修改就会永久保存到数据库中。</li>
</ul>
<p>read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。<br>    一个事务读取到另一个事务尚未提交的数据,称之为脏读</p>
<p>read commit 读已提交，两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。<br>    个事务读取到另一个事务已提交的数据,导致对同一条记录读取两次以上的结果不一致,称之为不可重复读</p>
<p>repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。<br>    一个事务读取到另一个事务已经提交的delete或者insert数据,导致对同一张表读取两次以上结果不一致,称之为幻读   </p>
<p>serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。</p>
<p>A原子性由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql<br>C一致性一般由代码层面来保证<br>I隔离性由MVCC来保证<br>D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</p>
<p>MVCC叫做多版本并发控制，实际上就是保存了数据在某个时间节点的快照。</p>
<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><p>生产者弄丢了数据<br>    可以选择使用rabbitmq提供是事物功能<br>    可以开启confirm模式</p>
<p>rabbitmq自己丢了数据<br>    设置消息持久化到磁盘</p>
<p>消费端弄丢了数据<br>    使用rabbitmq提供的ack机制，首先关闭rabbitmq的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。</p>
<p>复杂的问题简单化——拆分<br>服务提供者，服务消费者，注册中心</p>
<p>服务注册——服务启动时将自己的信息存储在这册中心<br>服务发现——消费者从注册中心获取服务提供者的网络信息，通过该信息进行服务调用</p>

        
        <!-------------->
      </div>
      <div class="post-tags">
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2020/11/26/multithreading/">多线程</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2020-11-26</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a>
              
          
          <!---------------------------------------->
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <p><img src="/img/con_pro.png">  </p>
<p><img src="/img/thread.png">  </p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li><p>在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。   </p>
</li>
<li><p>缓存导致的可见行问题</p>
<pre><code>  一个线程对共享变量的修改，另一个线程能够立刻看到——可见性   </code></pre>
</li>
<li><p>线程切换带来的原子性问题   </p>
</li>
<li><p>变异优化带来的有序性问题</p>
</li>
<li><p>Java内存模型规范了jvm如何提供按需禁用缓存和编译优化的方法：volatile、synchronized、final 关键字及六项happens-before【前一个操作的结果对后续的操作是可见的】原则。   </p>
</li>
<li><p>volatile:原始意义为禁用cpu缓存   </p>
</li>
<li><p>final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化   </p>
</li>
<li><p><font color=#FF0000 > 不能用可变对象做锁 </font></p>
</li>
</ul>
<h2 id="1-程序的顺序性规则："><a href="#1-程序的顺序性规则：" class="headerlink" title="1 程序的顺序性规则："></a>1 程序的顺序性规则：</h2><pre><code>    这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作   </code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下代码来源于【参考1】</span><br><span class="line">class VolatileExample &#123;</span><br><span class="line">  int x &#x3D; 0;</span><br><span class="line">  volatile boolean v &#x3D; false;</span><br><span class="line">  public void writer() &#123;</span><br><span class="line">    x &#x3D; 42;</span><br><span class="line">    v &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  public void reader() &#123;</span><br><span class="line">    if (v &#x3D;&#x3D; true) &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里x会是多少呢？</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-volatile-变量规则"><a href="#2-volatile-变量规则" class="headerlink" title="2 volatile 变量规则"></a>2 volatile 变量规则</h2><pre><code>这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。</code></pre>
<h2 id="3-传递性"><a href="#3-传递性" class="headerlink" title="3 传递性"></a>3 传递性</h2><pre><code>这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</code></pre>
<h2 id="4-管程中的锁规则【synchronzied】"><a href="#4-管程中的锁规则【synchronzied】" class="headerlink" title="4 管程中的锁规则【synchronzied】"></a>4 管程中的锁规则【synchronzied】</h2><pre><code>这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</code></pre>
<h2 id="5-线程start规则"><a href="#5-线程start规则" class="headerlink" title="5 线程start规则"></a>5 线程start规则</h2><pre><code>它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</code></pre>
<h2 id="6-线程join规则"><a href="#6-线程join规则" class="headerlink" title="6 线程join规则"></a>6 线程join规则</h2><pre><code>它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。</code></pre>
<h2 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h2><ul>
<li>互斥，共享资源 X 和 Y 只能被一个线程占用；</li>
<li>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li>
<li>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</li>
<li>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</li>
</ul>
<h2 id="用“等待-通知”机制优化循环等待"><a href="#用“等待-通知”机制优化循环等待" class="headerlink" title="用“等待-通知”机制优化循环等待"></a>用“等待-通知”机制优化循环等待</h2><pre><code>Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法就能轻松实现。</code></pre>
<h1 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h1><h2 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h2><h2 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h2><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><h1 id="管程，对应的英文是-Monitor"><a href="#管程，对应的英文是-Monitor" class="headerlink" title="管程，对应的英文是 Monitor"></a>管程，对应的英文是 Monitor</h1><p><font color=#FF0000 > 管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的 </font></p>
<p>管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。</p>
<h1 id="线程数量"><a href="#线程数量" class="headerlink" title="线程数量"></a>线程数量</h1><p>对于 CPU 密集型计算，多线程本质上是提升多核 CPU 的利用率，所以对于一个 4 核的 CPU，每个核一个线程，理论上创建 4 个线程就可以了，再多创建线程也只是增加线程切换的成本。所以，对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的。不过在工程上，线程的数量一般会设置为“CPU 核数 +1”，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。   </p>
<p>对于 I/O 密集型的计算场景，比如前面我们的例子中，如果 CPU 计算和 I/O 操作的耗时是 1:1，那么 2 个线程是最合适的。如果 CPU 计算和 I/O 操作的耗时是 1:2，那多少个线程合适呢？是 3 个线程；最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]<br><font color=#FF0000 > 伪标准（经验值）：2 * CPU 的核数 + 1 </font></p>
<h1 id="Lock，Condition"><a href="#Lock，Condition" class="headerlink" title="Lock，Condition"></a>Lock，Condition</h1><p>Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题。</p>
<ul>
<li>永远只在更新对象的成员变量时加锁</li>
<li>永远只在访问可变的成员变量时加锁</li>
<li>永远不在调用其他对象的方法时加锁</li>
</ul>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><ul>
<li>允许多个线程同时读共享变量</li>
<li>只允许一个线程写共享变量</li>
<li>如果一线程在写共享变量，此时禁止读进程读共享变量<h1 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h1></li>
</ul>
<h1 id="Thread-Runnable"><a href="#Thread-Runnable" class="headerlink" title="Thread,Runnable"></a>Thread,Runnable</h1><pre><code>继承Thread类，并重写run方法

实现Runnable接口</code></pre>
<h1 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h1><p>锁与同步</p>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><pre><code>volatile关键字能够保证内存的可⻅性，如果⽤volatile关键字声明了⼀个变 量，在⼀个线程⾥⾯改变了这个变量的值，那其它线程是⽴⻢可⻅更改后的 值的。


sleep⽅法是不会释放当前的锁的，⽽wait⽅法会</code></pre>

        
        <!-------------->
      </div>
      <div class="post-tags">
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2020/11/18/java-study/">Java 基础</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2020-11-18</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a>
              
          
          <!---------------------------------------->
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h1 id="8种基本类型"><a href="#8种基本类型" class="headerlink" title="8种基本类型"></a>8种基本类型</h1><pre><code>char,boolean,byte,int,long,float,double   </code></pre>
<h1 id="1-JVM"><a href="#1-JVM" class="headerlink" title="1.JVM"></a>1.JVM</h1><pre><code>Java 虚拟机就是一个字节码翻译器，它将字节码文件翻译成各个系统对应的机器码，确保字节码文件能在各个系统正确运行。</code></pre>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><pre><code>前端编译器：Sun——javac、Eclipse JDT(ECJ)
    将java源文件编译成字节码
JIT编译器：字节码到机器码
    当源代码转化为字节码之后，其实要运行程序，有两种选择。一种是使用 Java 解释器解释执行字节码，另一种则是使用 JIT 编译器将字节码转化为本地机器代码。</code></pre>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p><img src="/img/jvm.png">   </p>
<pre><code>共有：java堆
     方法区
     常量池
    Eden：from ：to = 8:1:1
私有：程序计数器——指向虚拟机字节码指令的位置；唯一一个无OOM的区域
     java虚拟机栈——生命周期同县城；一个线程中每调用一个方法创建一个栈帧；栈帧结构【本地变量表】
     本地方去栈</code></pre>
<h2 id="JVM-类加载"><a href="#JVM-类加载" class="headerlink" title="JVM 类加载"></a>JVM 类加载</h2><pre><code>JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：
加载-将字节码转化为二进制字节流加载到内存中、验证、准备、解析、初始化、使用、卸载。</code></pre>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><pre><code>引用计数、根可达
标记清除算法：产生不连续内存碎片
复制算法：空间利用率低
标记压缩：</code></pre>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><pre><code>串行回收器、并行回收器、CMS回收器、G1回收器

Serial收集器：单线程；简单高效；收集过程暂停所有线程；复制算法
ParNew收集器：多线程版Serial；
ParallelScavenge收集器：复制算法 注重吞吐量

Serial Old 单线程；标记-整理算法
Parallel Old ：多线程；标记-整理算法 吞吐量优先

CMS收集器：最短回收停顿时间；标记-清除算法；并发收集、低停顿；产生大量空间碎片、并发阶段降低吞吐量
    初始标记：标记GC ROOTs能关联的对象   STW
    并发标记：进行GC Roots Tracing
    重新标记：修改并发标记因用户程序变动的内容 STW
    并发清除

G1收集器：并行与并发、分代收集、空间整合（标记-整理）；将整个Java堆分为多个大小相等的独立区域；分代不是物理隔离
    初始标记：标记GC Roots能够关联的对象，并且修改TAMS的值，需要暂停用户线程
    并发标记：从GC Roots进行可达分析，找出存活对象，与用户线程并发执行
    最终标记：修正并发标记阶段因用户程序的并发执行导致的变动数据，需要暂停用户线程
    筛选回收：对各个Reion的回收价值和成本进行排序，根据用户所期望的GC停顿时间指定回收计划</code></pre>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><pre><code>强引用所指向的对象在任何时候都不会被系统回收，强引用可能导致内存泄漏。</code></pre>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><h2 id="需引用"><a href="#需引用" class="headerlink" title="需引用"></a>需引用</h2><pre><code>    </code></pre>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><pre><code>无序，不可重复
底层用Hash表实现
存取数据块
内部是hashmap</code></pre>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><pre><code>无序，不可重复
底层用二叉树
排序存储
内部是TreeMap的SortedSet</code></pre>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><pre><code>采用hash表存储，并用双向聊表记录插入顺序
哪不是LinkedHashMap</code></pre>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="arraylist"><a href="#arraylist" class="headerlink" title="arraylist"></a>arraylist</h3><pre><code>排列有序，可重复
底层用数据
查询快，增删慢，getter setter 快
线程不安全
扩容 *1.5+1</code></pre>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><pre><code>有序，可重复
数组
查询快，增删慢
线程安全、效率低
扩容 *1</code></pre>
<h3 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h3><pre><code>有序，可重复
双向链表
查询慢，增删快   add remove 快
线程不安全</code></pre>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><pre><code>在两端出入的List，可用数组或连标实现</code></pre>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><pre><code>键不可重复，
底层hash表
线程不安全
允许key=null（唯一）</code></pre>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><pre><code>键不可重复
底层hash表
线程安全
key、value都不能为null</code></pre>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><pre><code>建不可重复
底层二叉树</code></pre>

        
        <!-------------->
      </div>
      <div class="post-tags">
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2020/10/21/%08design-pattern/">Design patterns</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2020-10-21</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a>
              
          
          <!---------------------------------------->
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</span><br><span class="line">对于简单的程序开发，可能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。</span><br></pre></td></tr></table></figure>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><pre><code>单一职责
里氏替换
依赖倒置
接口隔离
迪米特
开闭</code></pre>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h3 id="创建型：用来创建对象的模式"><a href="#创建型：用来创建对象的模式" class="headerlink" title="创建型：用来创建对象的模式"></a>创建型：用来创建对象的模式</h3><h4 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h4><h4 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h4><h4 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3.抽象工厂"></a>3.抽象工厂</h4><h4 id="4-建造者"><a href="#4-建造者" class="headerlink" title="4.建造者"></a>4.建造者</h4><h4 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h4><h3 id="结构型：讨论的是类和对象的结构；"><a href="#结构型：讨论的是类和对象的结构；" class="headerlink" title="结构型：讨论的是类和对象的结构；"></a>结构型：讨论的是类和对象的结构；</h3><h4 id="6-代理模式"><a href="#6-代理模式" class="headerlink" title="6.代理模式"></a>6.代理模式</h4><h4 id="7-装饰模式"><a href="#7-装饰模式" class="headerlink" title="7.装饰模式"></a>7.装饰模式</h4><h4 id="8-适配器"><a href="#8-适配器" class="headerlink" title="8.适配器"></a>8.适配器</h4><h4 id="9-组合"><a href="#9-组合" class="headerlink" title="9.组合"></a>9.组合</h4><h4 id="10-桥接"><a href="#10-桥接" class="headerlink" title="10.桥接"></a>10.桥接</h4><h4 id="11-外观"><a href="#11-外观" class="headerlink" title="11.外观"></a>11.外观</h4><h4 id="12-享元模式"><a href="#12-享元模式" class="headerlink" title="12.享元模式"></a>12.享元模式</h4><h3 id="行为型：对象的行为"><a href="#行为型：对象的行为" class="headerlink" title="行为型：对象的行为"></a>行为型：对象的行为</h3><h4 id="13-模版方法"><a href="#13-模版方法" class="headerlink" title="13.模版方法"></a>13.模版方法</h4><h4 id="14-命令"><a href="#14-命令" class="headerlink" title="14.命令"></a>14.命令</h4><h4 id="15-责任链"><a href="#15-责任链" class="headerlink" title="15.责任链"></a>15.责任链</h4><h4 id="16-策略"><a href="#16-策略" class="headerlink" title="16.策略"></a>16.策略</h4><h4 id="17-迭代器"><a href="#17-迭代器" class="headerlink" title="17.迭代器"></a>17.迭代器</h4><h4 id="18-中介者"><a href="#18-中介者" class="headerlink" title="18.中介者"></a>18.中介者</h4><h4 id="19-观察者"><a href="#19-观察者" class="headerlink" title="19.观察者"></a>19.观察者</h4><h4 id="20-备忘录"><a href="#20-备忘录" class="headerlink" title="20.备忘录"></a>20.备忘录</h4><h4 id="21-访问者"><a href="#21-访问者" class="headerlink" title="21.访问者"></a>21.访问者</h4><h4 id="22-状态"><a href="#22-状态" class="headerlink" title="22.状态"></a>22.状态</h4><h4 id="23-解释器"><a href="#23-解释器" class="headerlink" title="23.解释器"></a>23.解释器</h4>
        
        <!-------------->
      </div>
      <div class="post-tags">
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2020/10/19/new-start/">New Start</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2020-10-19</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a>
              
          
          <!---------------------------------------->
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <p>Welcome to My blog! </p>
<p>My name is peng leng, a programmer. I graduated from Shandong University in 2012， and like to play basketball,</p>
<h2 id="New-Start"><a href="#New-Start" class="headerlink" title="New Start"></a>New Start</h2><p> <img src="/img/001.png"></p>

        
        <!-------------->
      </div>
      <div class="post-tags">
      
    </div>
    </article>
  
    <article class="post" id="post-excerpt">
      <header>
        <div class="post-title">
          <h1><a class="post-title-link" href="/2020/10/16/hello-world/">Quick Start</a></h1>
        </div>
        <div class="post-meta">
          <span class="post-time"><i class="iconfont icon-calendar"></i>2020-10-16</span>
          
              
                <i class="iconfont icon-divide"></i>
                <i class="iconfont icon-folder" style="color: #8a8a8a;"></i>
                <a class="post-category" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a>
              
          
          <!---------------------------------------->
            
        <!----------------------------------------->
        </div>
      </header>
      <div class="post-content">
        <!-------------->
        
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

        
        <!-------------->
      </div>
      <div class="post-tags">
      
    </div>
    </article>
  
</section>

          
     <nav class="pagination">
    
    
  </nav>


          

      </main>
    </div>
    <footer>
      <div class="social-links">
        
          
            <a target="_blank" rel="noopener" href="https://www.zhihu.com/"><i class="iconfont icon-zhihu"></i></a>
          
        
          
            <a target="_blank" rel="noopener" href="https://weibo.com"><i class="iconfont icon-weibo"></i></a>
          
        
          
            <a target="_blank" rel="noopener" href="https://github.com/"><i class="iconfont icon-github"></i></a>
          
        
      </div>
      
        <div class="quote">
          <p>Love all, trust a few, do wrong to none.——William Shakespeare</p>
        </div>
      
      <div class="copyright">
        <p>
          由 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
          <span>|</span>
          主题 - <a target="_blank" rel="noopener" href="https://github.com/wa-ri/hexo-theme-ztopic">ztopic</a
        </p>
        <p>
          <span>
          
          &copy;
          
            2021
          
          </span>
          <i class="iconfont icon-circle"></i>
          <span>LengPeng</span>
        </p>
      </div>
</footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <div id="mobile-nav">
  <nav id="mobile-nav-menu">
    
      <a href="/" class="mobile-nav-link"><i class="iconfont icon-home"></i>首页</a>
    
      <a href="/archives" class="mobile-nav-link"><i class="iconfont icon-archive"></i>归档</a>
    
      <a href="/categories" class="mobile-nav-link"><i class="iconfont icon-category"></i>分类</a>
    
      <a href="/about" class="mobile-nav-link"><i class="iconfont icon-about"></i>关于</a>
    
    <div class="mobile-intro"><i class="iconfont icon-pen"></i>practice makes perfect</div>
  </nav>
</div>


  
<script src="/libs/jQuery/jquery-3.2.1.min.js"></script>

  
<script src="/libs/slideout/slideout.min.js"></script>

  
    
<link rel="stylesheet" href="/libs/fancybox/jquery.fancybox.css">

    
<script src="/libs/fancybox/jquery.fancybox.pack.js"></script>

  
  

  
<script src="/js/ztopic.js"></script>

</body>
</html>
